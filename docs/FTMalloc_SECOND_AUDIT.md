### FTMalloc — второй аудит после внедрения правок (2025‑08‑07)

Итог: существенные замечания из первого аудита устранены. Проект собирается, все тесты (включая новые) проходят. Требования subject соблюдены: mmap/munmap, зоны TINY/SMALL с гарантией ≥100 аллокаций, LARGE — индивидуальные маппинги, выравнивание 16 байт, визуализация в порядке возрастания адресов, thread‑safe через единственный глобальный мьютекс без гонок.

Ниже — оставшиеся неточности и улучшения, которые следует применить для полной безупречности.

---

### Must fix (логическая полнота/консистентность)
- Несогласованность использования смещения до payload
  - Файл: `src/swift/Allocator.swift`
  - Проблема: в нескольких местах используется `blockHeaderSize()` там, где после введения `blockPayloadOffset()` должно учитываться именно выровненное смещение.
  - Конкретно:
    - `ft_internal_free`: `let bh = (p - blockHeaderSize())...` — следует вычитать `blockPayloadOffset()` (как сделано в остальных путях).
    - `mergeWithNextIfFree`/`mergeWithPrevIfFree`: при объединении блоков используется `blockHeaderSize()`; согласно новой модели расстояние между заголовками равно `blockPayloadOffset() + size`. Нужно заменить на `blockPayloadOffset()`.
  - Текущие тесты зелёные, вероятно потому что `MemoryLayout<BlockHeader>.stride` кратен 16 на данной платформе, но для строгой корректности и переносимости необходимо заменить везде на `blockPayloadOffset()`.

---

### Should fix (устойчивость/поддерживаемость)
- `alignUp` при невалидном `alignment` молча понижает его до 1
  - Файл: `src/swift/Util.swift`
  - Рекомендация: заменить на `precondition`/`assert` или возвращать исходное значение без выравнивания. Тихое изменение семантики ухудшает диагностику ошибок.

- Модификация списка LARGE в `show_alloc_mem`
  - Файл: `src/swift/Introspection.swift`
  - Текущая стратегия сортировки по адресу помечает узлы специальным «сентинелом» в `prev` и затем восстанавливает. Это безопасно под глобальной блокировкой, но отступает от инвариантов структуры.
  - Рекомендация: альтернативно обойти список без модификации, находя минимум каждый проход и запоминая «границу» (двойной цикл без маркера), либо временно реверсировать через `next` только для печати. Оставить как есть допустимо, но стоит документировать инвариант «во время печати указатели могут временно нарушаться» (уже под замком).

- Makefile: проверка наличия `nm`
  - Файл: `Makefile`
  - В цели `symbols` используется `command -v $(NM)`, тогда как `$(NM)` содержит флагами (`nm -gU`). Проверка всегда провалится. Лучше проверять `nm` без флагов и затем вызывать `$(NM)`.

- Обработка «чужих» указателей в `free`
  - Сейчас поведение при `free` неверного/смещённого указателя остаётся неопределённым (по стандарту это ок). Добавлен дымовой тест, который не падает. Для отказоустойчивости можно добавить валидацию принадлежности указателя зоне/списку перед модификацией метаданных, но это не обязательное требование subject.

---

### Повторная валидация требований subject
- Имя библиотеки и симлинк: соответствует (`libft_malloc_$HOSTTYPE.so` и `libft_malloc.so`).
- Использование только `mmap`/`munmap`/`getpagesize|sysconf`: соответствует.
- Зоны: `zoneSizeFor` гарантирует ≥100 блоков (учтены `ZoneHeader`, `BlockHeader`, выравнивание, округление до страницы).
- Выравнивание: введён `blockPayloadOffset()` и выравнивание начала первого блока; payload 16‑байтно выровнен.
- Потоки: глобальный мьютекс `PTHREAD_MUTEX_INITIALIZER`, ленивая инициализация исключена; одна глобальная переменная — соблюдено.
- `show_alloc_mem`: печать по возрастанию адресов; исключены Swift‑аллокации под замком; C‑печать без heap.
- Защиты от переполнений: добавлены гварды в критических местах.

---

### Предлагаемые точечные правки
- В `Allocator.swift` заменить оставшиеся `blockHeaderSize()` на `blockPayloadOffset()` в:
  - Восстановление заголовка из payload в `ft_internal_free`.
  - Объединение блоков в `mergeWithNextIfFree` и `mergeWithPrevIfFree`.
- В `Util.alignUp` ужесточить контракт для `alignment` (assert/precondition).
- В `Makefile` поправить проверку наличия `nm`.

После этих исправлений проект будет соответствовать не только формальным требованиям subject, но и внутренне консистентной модели адресной арифметики, введённой на втором шаге.
