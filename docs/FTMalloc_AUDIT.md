### FTMalloc: строгий аудит реализации malloc (Swift/C)

Версия предмета: см. `docs/en.subject.txt` (6.2)
Дата аудита: 2025‑08‑07

---

### Итог в 1 абзаце
Проект компилируется, все предоставленные тесты проходят. Архитектура в целом соответствует предмету (mmap/munmap, зоны для TINY/SMALL, отдельные LARGE, C‑ABI). Тем не менее есть критичные несоответствия и дефекты: нарушение жесткого требования «>=100 аллокаций на зону» (SMALL как минимум), гонка при инициализации глобального мьютекса (потенциальная неопределенная работа и UB под гонкой), возможная рекурсия/взаимоблокировка в `show_alloc_mem` из‑за скрытых аллокаций Swift, некорректный учет `usedBytes` при in‑place росте `realloc` (может увести в отрицательные значения), отсутствие защит от переполнения размеров/ограничений ресурса, а также риски несовместимой выравнивающей арифметики, зависящей от фактической укладки `struct` в Swift. Эти пункты требуют исправления до защиты.

---

### Соответствие предмету
- **Название и симлинк библиотеки**: OK
  - `libft_malloc_$HOSTTYPE.so` и симлинк `build/libft_malloc.so` создаются корректно (см. `Makefile`).
  - `HOSTTYPE` подставляется как `uname -m`_`uname -s` при пустом значении: OK.
- **Разрешенные системные вызовы**: OK
  - Используются `mmap(2)`, `munmap(2)`, `getpagesize`/`sysconf(_SC_PAGESIZE)`; вывод — через `write(2)` в С‑хелперах.
- **Потоки**: формально покрыто, но есть дефект инициализации (см. «Критичные дефекты»).
- **Требование «каждая зона >= 100 аллокаций»**: НЕ СООТВЕТСТВУЕТ
  - Реализация `zoneSizeFor` не зависит от `tinyMaxBlockSize`/`smallMaxBlockSize` и закладывает фиксированную «емкость» `128 * (BlockHeader + 16)`, после чего округляет до размера страницы. Для SMALL зона при типичном размере страницы (например, 16 KiB) гарантированно не вмещает 100 блоков размера до 4096 + накладные — противоречит предмету.
- **Визуализация `show_alloc_mem`**: формат в целом совпадает; порядок внутри TINY/SMALL соответствует порядку в списке блоков (по адресам), LARGE печатаются в порядке вставки (см. «Замечания/риски»).

---

### Критичные дефекты (must fix)
- **Инициализация мьютекса — гонка и UB**
  - Файл: `src/c/mutex.c`
  - Проблема: `ft_mutex_init_if_needed` использует `g_inited` без атомарности/барьеров и может вызываться конкурентно несколькими потоками. Возможна гонка и двойной `pthread_mutex_init` над одним объектом — это UB.
  - Исправление: использовать `pthread_once` либо статический `pthread_mutex_t g_mutex = PTHREAD_MUTEX_INITIALIZER` и удалить ленивую инициализацию; если хочется «ленивости», обернуть проверку в `pthread_once`/`os_unfair_lock`/`stdatomic.h` с правильными порядками.
  - Дополнительно: предмет разрешает «одну глобальную переменную для thread‑safe». Сейчас используется как минимум две (`g_mutex`, `g_inited`). Это формально нарушает правило. Объедините индикатор инициализации с самим мьютексом (через `pthread_once`) — второй глобальной переменной не будет.

- **`realloc` in‑place grow не обновляет `usedBytes`**
  - Файл: `src/swift/Allocator.swift`
  - Ветвь роста за счет соседнего свободного блока ("Try in-place grow into next free block") объединяет блоки, возможно делит остаток, но **не увеличивает** `zh.pointee.usedBytes` на дельту роста. При этом при `free` списывается уже увеличенный размер, что уводит `usedBytes` в отрицательные значения. Это логическая ошибка и потенциальный источник неконсистентности.
  - Исправление: после успешного расширения in‑place добавить `zh.pointee.usedBytes &+= (newSize - oldSize)`.

- **`show_alloc_mem` может вызывать скрытые аллокации Swift под глобальной блокировкой**
  - Файл: `src/swift/Introspection.swift`
  - `cstr(_:)` строит `Array(s.utf8CString)`, что, как правило, приводит к heap‑аллокации через рантайм Swift. Поскольку `show_alloc_mem` выполняется под глобальным мьютексом аллокатора, любое обращение рантайма к `malloc` приведет к реентерации `malloc`/взаимоблокировке (мьютекс не рекурсивный). Тесты прошли, но это **хрупко и невалидно** по требованиям (внутренние операции аллокатора не должны зависеть от malloc).
  - Исправление: использовать статические C‑строки (например, `static const char label_TINY[] = "TINY";`) и передавать указатели без формирования Swift‑массивов. Либо сформировать `UnsafePointer<CChar>` в заранее выделенном статическом буфере на C‑стороне.

- **Зоны SMALL не удовлетворяют требованию «>=100 аллокаций»**
  - Файл: `src/swift/ZoneManager.swift` (`zoneSizeFor`) + пороги в `src/swift/Metadata.swift`.
  - Как минимум для SMALL при `smallMaxBlockSize = 4096` итоговый размер зоны (округлен до страницы) не обеспечивает 100 блоков по (4096 + header). Требуется пересчитать N и M исходя из максимальных размеров класса и включив накладные (`ZoneHeader`, `BlockHeader`, выравнивание), затем округлить в страницы.

- **Защита от переполнения размеров отсутствует**
  - Файлы: `src/swift/Allocator.swift`, `src/swift/ZoneManager.swift`.
  - Нет проверок на переполнение при: `blockHeaderSize() + size` (LARGE), `blockHeaderSize() + need` (split), арифметике с `Int` в `alignUp`. При экстремальных значениях (`size > Int.max - header`) возможен wraparound и маппинг слишком малого региона с последующим выходом за границы — UB.
  - Исправление: ввести гварды вида `if size <= 0 || size > Int.max - blockHeaderSize() { return nil }`, аналогично для сплитов/комбинаций/ceilToPages. По возможности ориентироваться на `getrlimit(RLIMIT_DATA)`/`RLIMIT_AS`.

---

### Замечания/риски (should fix)
- **Выравнивание зависит от укладки Swift‑структур**
  - Файлы: `src/swift/Metadata.swift`, `src/swift/ZoneManager.swift`, `src/swift/Allocator.swift`.
  - Гарантия 16‑байтового выравнивания достигается суммой `zoneHeaderSize()` + `blockHeaderSize()`, но ни один из размеров явно не выравнивается на `minimumAlignment`. На другой версии компилятора/платформе stride мог бы дать несоответствие. 
  - Исправление: обеспечить, что начало payload выровнено явно: выровнять смещение первого блока относительно базы зоны (`alignUp(zoneHeaderSize(), to: minimumAlignment)`), а также гарантировать, что `blockHeaderSize()` кратен `minimumAlignment` (например, дополнительным паддингом в определении `BlockHeader`, либо выравнивать адрес начала payload).

- **Порядок вывода LARGE не гарантирует сортировку по адресам**
  - Сейчас LARGE блоки печатаются в порядке вставки. Предмет формулирует «форматирован по возрастанию адресов». Рекомендуется поддержать сортировку или хранить LARGE в отсортированном по адресу двусвязанном списке.

- **Отсутствуют проверки на чужие указатели в `free`/`realloc`**
  - Допустимо по предмету (определение поведения не требуется), но для устойчивости можно добавить базовые валидации зоны и заголовка, чтобы не повредить внутренние списки.

- **`Util.alignUp` не валидирует, что `alignment` — степень двойки**
  - Текущее вычисление с маской подразумевает степень двойки. Добавьте assert/guard или универсальную реализацию.

- **Платформенная линковка Swift на Linux**
  - В `Makefile` используется `-Xlinker -lpthread`. Практически работает, но документируйте/проверьте на используемой версии тулчейна. В противном случае — `-Xlinker -l` «подвисает» как два отдельных аргумента для линкера не у всех сборочных цепочек.

- **Формальное соблюдение «одна глобальная переменная для thread‑safe»**
  - См. критичный пункт про `mutex.c` — сейчас их две. Переведите на `pthread_once`/`PTHREAD_MUTEX_INITIALIZER`.

---

### Предлагаемые правки (high level)
- Мьютекс:
  - Заменить ленивую инициализацию на `pthread_once` или статический инициализатор, удалить `g_inited`.
- `realloc` in‑place grow: корректно обновлять `usedBytes` на дельту роста.
- Зоны:
  - Пересчитать `zoneSizeFor(type:)` отдельно для TINY и SMALL: размер должен вмещать ≥100 блоков размера соответствующего класса с учетом `BlockHeader`, выравнивания и `ZoneHeader`, затем округлить в размер страницы.
- Выравнивание:
  - Выровнять начало первого блока по `minimumAlignment`; гарантировать кратность `blockHeaderSize()` либо компенсировать смещением payload.
- Безопасность размеров:
  - Добавить гварды от переполнения и необоснованно больших запросов (по `Int.max` и по `getrlimit`).
- `show_alloc_mem`:
  - Исключить любые Swift‑аллокации; использовать C‑строки/буферы без heap.
  - Опционально: сортировать LARGE по адресу.

---

### Рекомендуемые дополнительные тесты (не блокирующие текущий билд)
- `test_zone_capacity.c` (новый):
  - Проверяет, что `zoneSizeFor(TINY/SMALL)` (через `ft_debug_zone_roundtrip`) позволяет минимум 100 блоков размера `tinyMaxBlockSize`/`smallMaxBlockSize` с учетом `BlockHeader` и `ZoneHeader`.
- `test_realloc_inplace_usedbytes.c` (новый):
  - Через C‑ABI отладочные экспортируемые функции (понадобятся новые хуки) проверяет, что `usedBytes` увеличивается на дельту при in‑place росте.
- `test_mutex_once.c` (стресс):
  - Имитирует одновременные первые вызовы `malloc` из множества потоков, проверяя отсутствие крашей (детект гонки сложно, но тест полезен).
- `test_alignment_property.c`:
  - Случайный набор размеров; проверяет, что адреса payload кратны 16, а границы блоков не пересекаются.

---

### Примеры мест, требующих правок (указатели)
- Гонка инициализации мьютекса:
```7:24:src/c/mutex.c
void ft_mutex_init_if_needed(void) {
    if (!g_inited) {
        pthread_mutexattr_t attr;
        pthread_mutexattr_init(&attr);
        pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_NORMAL);
        pthread_mutex_init(&g_mutex, &attr);
        pthread_mutexattr_destroy(&attr);
        g_inited = 1;
    }
}
```
- Отсутствие обновления `usedBytes` при росте in‑place:
```263:276:src/swift/Allocator.swift
if let n = (bh.pointee.next?.assumingMemoryBound(to: BlockHeader.self)), n.pointee.isFree {
    let combined = bh.pointee.size + blockHeaderSize() + n.pointee.size
    if combined >= newSize {
        bh.pointee.next = n.pointee.next
        if let nn = n.pointee.next { blockHeaderPtr(nn).pointee.prev = UnsafeMutableRawPointer(bh) }
        bh.pointee.size = combined
        if let zoneBase = bh.pointee.zoneBase {
            let zh = header(zoneBase)
            // split to exact if big remainder
            maybeSplitBlock(bh, need: newSize, zoneHeader: zh)
        }
        return ptr
    }
}
```
Здесь необходимо добавить увеличение `usedBytes` на `(newSize - oldSize)`.

- Потенциальная аллокация в `show_alloc_mem` (под глобальной блокировкой):
```19:23:src/swift/Introspection.swift
@inline(__always)
private func cstr(_ s: String) -> [CChar] {
    let arr = Array(s.utf8CString)
    return arr
}
```
Заменить на статические C‑строки без участия Swift‑коллекций.

- Несоответствие «>= 100 аллокаций на зону»:
```16:21:src/swift/ZoneManager.swift
public func zoneSizeFor(type: ZoneType) -> Int {
    let header = zoneHeaderSize()
    let capacity = 128 * zoneCapacityUnit()
    let total = header + capacity
    return ceilToPages(total)
}
```
Следует рассчитывать размер исходя из `tinyMaxBlockSize`/`smallMaxBlockSize` так, чтобы вместить ≥100 блоков каждого класса.

---

### Мелкие улучшения
- В `Makefile` добавить явную зависимость `$(LIB_SYMLINK): | $(BUILD_DIR)` и проверку доступности `egrep`/`nm` для кроссплатформенности `symbols`.
- В `Util.alignUp` добавить защиту от некорректных `alignment` и переполнений.
- В `Allocator`/`ZoneManager` унифицировать вспомогательные функции (`blockHeaderPtr`, `blockHeaderAt`) и убрать дублирующиеся.

---

### Заключение
Код качественный по структуре и покрыт тестами, но для строгого соответствия предмету и устойчивости под нагрузкой необходимо устранить отмеченные критичные дефекты (мьютекс, учет `usedBytes`, перерасчет размеров зон, запрет аллокаций в `show_alloc_mem`, проверки переполнений) и учесть риски выравнивания. После правок рекомендую добавить предложенные тесты и повторно провести ревизию.
